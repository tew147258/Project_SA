// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/tew147258/app/ent/borrow"
	"github.com/tew147258/app/ent/confirmation"
	"github.com/tew147258/app/ent/stadium"
	"github.com/tew147258/app/ent/user"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBorrow       = "Borrow"
	TypeConfirmation = "Confirmation"
	TypeStadium      = "Stadium"
	TypeUser         = "User"
)

// BorrowMutation represents an operation that mutate the Borrows
// nodes in the graph.
type BorrowMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	_type                      *string
	clearedFields              map[string]struct{}
	_BorrowConfirmation        map[int]struct{}
	removed_BorrowConfirmation map[int]struct{}
	done                       bool
	oldValue                   func(context.Context) (*Borrow, error)
}

var _ ent.Mutation = (*BorrowMutation)(nil)

// borrowOption allows to manage the mutation configuration using functional options.
type borrowOption func(*BorrowMutation)

// newBorrowMutation creates new mutation for $n.Name.
func newBorrowMutation(c config, op Op, opts ...borrowOption) *BorrowMutation {
	m := &BorrowMutation{
		config:        c,
		op:            op,
		typ:           TypeBorrow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBorrowID sets the id field of the mutation.
func withBorrowID(id int) borrowOption {
	return func(m *BorrowMutation) {
		var (
			err   error
			once  sync.Once
			value *Borrow
		)
		m.oldValue = func(ctx context.Context) (*Borrow, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Borrow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBorrow sets the old Borrow of the mutation.
func withBorrow(node *Borrow) borrowOption {
	return func(m *BorrowMutation) {
		m.oldValue = func(context.Context) (*Borrow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BorrowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BorrowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BorrowMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetType sets the type field.
func (m *BorrowMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the type value in the mutation.
func (m *BorrowMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the Borrow.
// If the Borrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BorrowMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *BorrowMutation) ResetType() {
	m._type = nil
}

// AddBorrowConfirmationIDs adds the BorrowConfirmation edge to Confirmation by ids.
func (m *BorrowMutation) AddBorrowConfirmationIDs(ids ...int) {
	if m._BorrowConfirmation == nil {
		m._BorrowConfirmation = make(map[int]struct{})
	}
	for i := range ids {
		m._BorrowConfirmation[ids[i]] = struct{}{}
	}
}

// RemoveBorrowConfirmationIDs removes the BorrowConfirmation edge to Confirmation by ids.
func (m *BorrowMutation) RemoveBorrowConfirmationIDs(ids ...int) {
	if m.removed_BorrowConfirmation == nil {
		m.removed_BorrowConfirmation = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_BorrowConfirmation[ids[i]] = struct{}{}
	}
}

// RemovedBorrowConfirmation returns the removed ids of BorrowConfirmation.
func (m *BorrowMutation) RemovedBorrowConfirmationIDs() (ids []int) {
	for id := range m.removed_BorrowConfirmation {
		ids = append(ids, id)
	}
	return
}

// BorrowConfirmationIDs returns the BorrowConfirmation ids in the mutation.
func (m *BorrowMutation) BorrowConfirmationIDs() (ids []int) {
	for id := range m._BorrowConfirmation {
		ids = append(ids, id)
	}
	return
}

// ResetBorrowConfirmation reset all changes of the "BorrowConfirmation" edge.
func (m *BorrowMutation) ResetBorrowConfirmation() {
	m._BorrowConfirmation = nil
	m.removed_BorrowConfirmation = nil
}

// Op returns the operation name.
func (m *BorrowMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Borrow).
func (m *BorrowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BorrowMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._type != nil {
		fields = append(fields, borrow.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BorrowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case borrow.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BorrowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case borrow.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Borrow field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BorrowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case borrow.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Borrow field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BorrowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BorrowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BorrowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Borrow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BorrowMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BorrowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BorrowMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Borrow nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BorrowMutation) ResetField(name string) error {
	switch name {
	case borrow.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Borrow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BorrowMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._BorrowConfirmation != nil {
		edges = append(edges, borrow.EdgeBorrowConfirmation)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BorrowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case borrow.EdgeBorrowConfirmation:
		ids := make([]ent.Value, 0, len(m._BorrowConfirmation))
		for id := range m._BorrowConfirmation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BorrowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_BorrowConfirmation != nil {
		edges = append(edges, borrow.EdgeBorrowConfirmation)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BorrowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case borrow.EdgeBorrowConfirmation:
		ids := make([]ent.Value, 0, len(m.removed_BorrowConfirmation))
		for id := range m.removed_BorrowConfirmation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BorrowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BorrowMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BorrowMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Borrow unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BorrowMutation) ResetEdge(name string) error {
	switch name {
	case borrow.EdgeBorrowConfirmation:
		m.ResetBorrowConfirmation()
		return nil
	}
	return fmt.Errorf("unknown Borrow edge %s", name)
}

// ConfirmationMutation represents an operation that mutate the Confirmations
// nodes in the graph.
type ConfirmationMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	bookingdate                 *time.Time
	bookingstart                *time.Time
	bookingend                  *time.Time
	hourstime                   *int
	addhourstime                *int
	clearedFields               map[string]struct{}
	_ConfirmationUser           *int
	cleared_ConfirmationUser    bool
	_ConfirmationStadium        *int
	cleared_ConfirmationStadium bool
	_ConfirmationBorrow         *int
	cleared_ConfirmationBorrow  bool
	done                        bool
	oldValue                    func(context.Context) (*Confirmation, error)
}

var _ ent.Mutation = (*ConfirmationMutation)(nil)

// confirmationOption allows to manage the mutation configuration using functional options.
type confirmationOption func(*ConfirmationMutation)

// newConfirmationMutation creates new mutation for $n.Name.
func newConfirmationMutation(c config, op Op, opts ...confirmationOption) *ConfirmationMutation {
	m := &ConfirmationMutation{
		config:        c,
		op:            op,
		typ:           TypeConfirmation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfirmationID sets the id field of the mutation.
func withConfirmationID(id int) confirmationOption {
	return func(m *ConfirmationMutation) {
		var (
			err   error
			once  sync.Once
			value *Confirmation
		)
		m.oldValue = func(ctx context.Context) (*Confirmation, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Confirmation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfirmation sets the old Confirmation of the mutation.
func withConfirmation(node *Confirmation) confirmationOption {
	return func(m *ConfirmationMutation) {
		m.oldValue = func(context.Context) (*Confirmation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfirmationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfirmationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ConfirmationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBookingdate sets the bookingdate field.
func (m *ConfirmationMutation) SetBookingdate(t time.Time) {
	m.bookingdate = &t
}

// Bookingdate returns the bookingdate value in the mutation.
func (m *ConfirmationMutation) Bookingdate() (r time.Time, exists bool) {
	v := m.bookingdate
	if v == nil {
		return
	}
	return *v, true
}

// OldBookingdate returns the old bookingdate value of the Confirmation.
// If the Confirmation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConfirmationMutation) OldBookingdate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBookingdate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBookingdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookingdate: %w", err)
	}
	return oldValue.Bookingdate, nil
}

// ResetBookingdate reset all changes of the "bookingdate" field.
func (m *ConfirmationMutation) ResetBookingdate() {
	m.bookingdate = nil
}

// SetBookingstart sets the bookingstart field.
func (m *ConfirmationMutation) SetBookingstart(t time.Time) {
	m.bookingstart = &t
}

// Bookingstart returns the bookingstart value in the mutation.
func (m *ConfirmationMutation) Bookingstart() (r time.Time, exists bool) {
	v := m.bookingstart
	if v == nil {
		return
	}
	return *v, true
}

// OldBookingstart returns the old bookingstart value of the Confirmation.
// If the Confirmation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConfirmationMutation) OldBookingstart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBookingstart is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBookingstart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookingstart: %w", err)
	}
	return oldValue.Bookingstart, nil
}

// ResetBookingstart reset all changes of the "bookingstart" field.
func (m *ConfirmationMutation) ResetBookingstart() {
	m.bookingstart = nil
}

// SetBookingend sets the bookingend field.
func (m *ConfirmationMutation) SetBookingend(t time.Time) {
	m.bookingend = &t
}

// Bookingend returns the bookingend value in the mutation.
func (m *ConfirmationMutation) Bookingend() (r time.Time, exists bool) {
	v := m.bookingend
	if v == nil {
		return
	}
	return *v, true
}

// OldBookingend returns the old bookingend value of the Confirmation.
// If the Confirmation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConfirmationMutation) OldBookingend(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBookingend is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBookingend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookingend: %w", err)
	}
	return oldValue.Bookingend, nil
}

// ResetBookingend reset all changes of the "bookingend" field.
func (m *ConfirmationMutation) ResetBookingend() {
	m.bookingend = nil
}

// SetHourstime sets the hourstime field.
func (m *ConfirmationMutation) SetHourstime(i int) {
	m.hourstime = &i
	m.addhourstime = nil
}

// Hourstime returns the hourstime value in the mutation.
func (m *ConfirmationMutation) Hourstime() (r int, exists bool) {
	v := m.hourstime
	if v == nil {
		return
	}
	return *v, true
}

// OldHourstime returns the old hourstime value of the Confirmation.
// If the Confirmation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConfirmationMutation) OldHourstime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHourstime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHourstime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHourstime: %w", err)
	}
	return oldValue.Hourstime, nil
}

// AddHourstime adds i to hourstime.
func (m *ConfirmationMutation) AddHourstime(i int) {
	if m.addhourstime != nil {
		*m.addhourstime += i
	} else {
		m.addhourstime = &i
	}
}

// AddedHourstime returns the value that was added to the hourstime field in this mutation.
func (m *ConfirmationMutation) AddedHourstime() (r int, exists bool) {
	v := m.addhourstime
	if v == nil {
		return
	}
	return *v, true
}

// ResetHourstime reset all changes of the "hourstime" field.
func (m *ConfirmationMutation) ResetHourstime() {
	m.hourstime = nil
	m.addhourstime = nil
}

// SetConfirmationUserID sets the ConfirmationUser edge to User by id.
func (m *ConfirmationMutation) SetConfirmationUserID(id int) {
	m._ConfirmationUser = &id
}

// ClearConfirmationUser clears the ConfirmationUser edge to User.
func (m *ConfirmationMutation) ClearConfirmationUser() {
	m.cleared_ConfirmationUser = true
}

// ConfirmationUserCleared returns if the edge ConfirmationUser was cleared.
func (m *ConfirmationMutation) ConfirmationUserCleared() bool {
	return m.cleared_ConfirmationUser
}

// ConfirmationUserID returns the ConfirmationUser id in the mutation.
func (m *ConfirmationMutation) ConfirmationUserID() (id int, exists bool) {
	if m._ConfirmationUser != nil {
		return *m._ConfirmationUser, true
	}
	return
}

// ConfirmationUserIDs returns the ConfirmationUser ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ConfirmationUserID instead. It exists only for internal usage by the builders.
func (m *ConfirmationMutation) ConfirmationUserIDs() (ids []int) {
	if id := m._ConfirmationUser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConfirmationUser reset all changes of the "ConfirmationUser" edge.
func (m *ConfirmationMutation) ResetConfirmationUser() {
	m._ConfirmationUser = nil
	m.cleared_ConfirmationUser = false
}

// SetConfirmationStadiumID sets the ConfirmationStadium edge to Stadium by id.
func (m *ConfirmationMutation) SetConfirmationStadiumID(id int) {
	m._ConfirmationStadium = &id
}

// ClearConfirmationStadium clears the ConfirmationStadium edge to Stadium.
func (m *ConfirmationMutation) ClearConfirmationStadium() {
	m.cleared_ConfirmationStadium = true
}

// ConfirmationStadiumCleared returns if the edge ConfirmationStadium was cleared.
func (m *ConfirmationMutation) ConfirmationStadiumCleared() bool {
	return m.cleared_ConfirmationStadium
}

// ConfirmationStadiumID returns the ConfirmationStadium id in the mutation.
func (m *ConfirmationMutation) ConfirmationStadiumID() (id int, exists bool) {
	if m._ConfirmationStadium != nil {
		return *m._ConfirmationStadium, true
	}
	return
}

// ConfirmationStadiumIDs returns the ConfirmationStadium ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ConfirmationStadiumID instead. It exists only for internal usage by the builders.
func (m *ConfirmationMutation) ConfirmationStadiumIDs() (ids []int) {
	if id := m._ConfirmationStadium; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConfirmationStadium reset all changes of the "ConfirmationStadium" edge.
func (m *ConfirmationMutation) ResetConfirmationStadium() {
	m._ConfirmationStadium = nil
	m.cleared_ConfirmationStadium = false
}

// SetConfirmationBorrowID sets the ConfirmationBorrow edge to Borrow by id.
func (m *ConfirmationMutation) SetConfirmationBorrowID(id int) {
	m._ConfirmationBorrow = &id
}

// ClearConfirmationBorrow clears the ConfirmationBorrow edge to Borrow.
func (m *ConfirmationMutation) ClearConfirmationBorrow() {
	m.cleared_ConfirmationBorrow = true
}

// ConfirmationBorrowCleared returns if the edge ConfirmationBorrow was cleared.
func (m *ConfirmationMutation) ConfirmationBorrowCleared() bool {
	return m.cleared_ConfirmationBorrow
}

// ConfirmationBorrowID returns the ConfirmationBorrow id in the mutation.
func (m *ConfirmationMutation) ConfirmationBorrowID() (id int, exists bool) {
	if m._ConfirmationBorrow != nil {
		return *m._ConfirmationBorrow, true
	}
	return
}

// ConfirmationBorrowIDs returns the ConfirmationBorrow ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ConfirmationBorrowID instead. It exists only for internal usage by the builders.
func (m *ConfirmationMutation) ConfirmationBorrowIDs() (ids []int) {
	if id := m._ConfirmationBorrow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConfirmationBorrow reset all changes of the "ConfirmationBorrow" edge.
func (m *ConfirmationMutation) ResetConfirmationBorrow() {
	m._ConfirmationBorrow = nil
	m.cleared_ConfirmationBorrow = false
}

// Op returns the operation name.
func (m *ConfirmationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Confirmation).
func (m *ConfirmationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ConfirmationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.bookingdate != nil {
		fields = append(fields, confirmation.FieldBookingdate)
	}
	if m.bookingstart != nil {
		fields = append(fields, confirmation.FieldBookingstart)
	}
	if m.bookingend != nil {
		fields = append(fields, confirmation.FieldBookingend)
	}
	if m.hourstime != nil {
		fields = append(fields, confirmation.FieldHourstime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ConfirmationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case confirmation.FieldBookingdate:
		return m.Bookingdate()
	case confirmation.FieldBookingstart:
		return m.Bookingstart()
	case confirmation.FieldBookingend:
		return m.Bookingend()
	case confirmation.FieldHourstime:
		return m.Hourstime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ConfirmationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case confirmation.FieldBookingdate:
		return m.OldBookingdate(ctx)
	case confirmation.FieldBookingstart:
		return m.OldBookingstart(ctx)
	case confirmation.FieldBookingend:
		return m.OldBookingend(ctx)
	case confirmation.FieldHourstime:
		return m.OldHourstime(ctx)
	}
	return nil, fmt.Errorf("unknown Confirmation field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ConfirmationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case confirmation.FieldBookingdate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookingdate(v)
		return nil
	case confirmation.FieldBookingstart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookingstart(v)
		return nil
	case confirmation.FieldBookingend:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookingend(v)
		return nil
	case confirmation.FieldHourstime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHourstime(v)
		return nil
	}
	return fmt.Errorf("unknown Confirmation field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ConfirmationMutation) AddedFields() []string {
	var fields []string
	if m.addhourstime != nil {
		fields = append(fields, confirmation.FieldHourstime)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ConfirmationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case confirmation.FieldHourstime:
		return m.AddedHourstime()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ConfirmationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case confirmation.FieldHourstime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHourstime(v)
		return nil
	}
	return fmt.Errorf("unknown Confirmation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ConfirmationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ConfirmationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfirmationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Confirmation nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ConfirmationMutation) ResetField(name string) error {
	switch name {
	case confirmation.FieldBookingdate:
		m.ResetBookingdate()
		return nil
	case confirmation.FieldBookingstart:
		m.ResetBookingstart()
		return nil
	case confirmation.FieldBookingend:
		m.ResetBookingend()
		return nil
	case confirmation.FieldHourstime:
		m.ResetHourstime()
		return nil
	}
	return fmt.Errorf("unknown Confirmation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ConfirmationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._ConfirmationUser != nil {
		edges = append(edges, confirmation.EdgeConfirmationUser)
	}
	if m._ConfirmationStadium != nil {
		edges = append(edges, confirmation.EdgeConfirmationStadium)
	}
	if m._ConfirmationBorrow != nil {
		edges = append(edges, confirmation.EdgeConfirmationBorrow)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ConfirmationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case confirmation.EdgeConfirmationUser:
		if id := m._ConfirmationUser; id != nil {
			return []ent.Value{*id}
		}
	case confirmation.EdgeConfirmationStadium:
		if id := m._ConfirmationStadium; id != nil {
			return []ent.Value{*id}
		}
	case confirmation.EdgeConfirmationBorrow:
		if id := m._ConfirmationBorrow; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ConfirmationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ConfirmationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ConfirmationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_ConfirmationUser {
		edges = append(edges, confirmation.EdgeConfirmationUser)
	}
	if m.cleared_ConfirmationStadium {
		edges = append(edges, confirmation.EdgeConfirmationStadium)
	}
	if m.cleared_ConfirmationBorrow {
		edges = append(edges, confirmation.EdgeConfirmationBorrow)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ConfirmationMutation) EdgeCleared(name string) bool {
	switch name {
	case confirmation.EdgeConfirmationUser:
		return m.cleared_ConfirmationUser
	case confirmation.EdgeConfirmationStadium:
		return m.cleared_ConfirmationStadium
	case confirmation.EdgeConfirmationBorrow:
		return m.cleared_ConfirmationBorrow
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ConfirmationMutation) ClearEdge(name string) error {
	switch name {
	case confirmation.EdgeConfirmationUser:
		m.ClearConfirmationUser()
		return nil
	case confirmation.EdgeConfirmationStadium:
		m.ClearConfirmationStadium()
		return nil
	case confirmation.EdgeConfirmationBorrow:
		m.ClearConfirmationBorrow()
		return nil
	}
	return fmt.Errorf("unknown Confirmation unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ConfirmationMutation) ResetEdge(name string) error {
	switch name {
	case confirmation.EdgeConfirmationUser:
		m.ResetConfirmationUser()
		return nil
	case confirmation.EdgeConfirmationStadium:
		m.ResetConfirmationStadium()
		return nil
	case confirmation.EdgeConfirmationBorrow:
		m.ResetConfirmationBorrow()
		return nil
	}
	return fmt.Errorf("unknown Confirmation edge %s", name)
}

// StadiumMutation represents an operation that mutate the Stadia
// nodes in the graph.
type StadiumMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	namestadium                 *string
	clearedFields               map[string]struct{}
	_StadiumConfirmation        map[int]struct{}
	removed_StadiumConfirmation map[int]struct{}
	done                        bool
	oldValue                    func(context.Context) (*Stadium, error)
}

var _ ent.Mutation = (*StadiumMutation)(nil)

// stadiumOption allows to manage the mutation configuration using functional options.
type stadiumOption func(*StadiumMutation)

// newStadiumMutation creates new mutation for $n.Name.
func newStadiumMutation(c config, op Op, opts ...stadiumOption) *StadiumMutation {
	m := &StadiumMutation{
		config:        c,
		op:            op,
		typ:           TypeStadium,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStadiumID sets the id field of the mutation.
func withStadiumID(id int) stadiumOption {
	return func(m *StadiumMutation) {
		var (
			err   error
			once  sync.Once
			value *Stadium
		)
		m.oldValue = func(ctx context.Context) (*Stadium, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Stadium.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStadium sets the old Stadium of the mutation.
func withStadium(node *Stadium) stadiumOption {
	return func(m *StadiumMutation) {
		m.oldValue = func(context.Context) (*Stadium, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StadiumMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StadiumMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StadiumMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetNamestadium sets the namestadium field.
func (m *StadiumMutation) SetNamestadium(s string) {
	m.namestadium = &s
}

// Namestadium returns the namestadium value in the mutation.
func (m *StadiumMutation) Namestadium() (r string, exists bool) {
	v := m.namestadium
	if v == nil {
		return
	}
	return *v, true
}

// OldNamestadium returns the old namestadium value of the Stadium.
// If the Stadium object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StadiumMutation) OldNamestadium(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNamestadium is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNamestadium requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamestadium: %w", err)
	}
	return oldValue.Namestadium, nil
}

// ResetNamestadium reset all changes of the "namestadium" field.
func (m *StadiumMutation) ResetNamestadium() {
	m.namestadium = nil
}

// AddStadiumConfirmationIDs adds the StadiumConfirmation edge to Confirmation by ids.
func (m *StadiumMutation) AddStadiumConfirmationIDs(ids ...int) {
	if m._StadiumConfirmation == nil {
		m._StadiumConfirmation = make(map[int]struct{})
	}
	for i := range ids {
		m._StadiumConfirmation[ids[i]] = struct{}{}
	}
}

// RemoveStadiumConfirmationIDs removes the StadiumConfirmation edge to Confirmation by ids.
func (m *StadiumMutation) RemoveStadiumConfirmationIDs(ids ...int) {
	if m.removed_StadiumConfirmation == nil {
		m.removed_StadiumConfirmation = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_StadiumConfirmation[ids[i]] = struct{}{}
	}
}

// RemovedStadiumConfirmation returns the removed ids of StadiumConfirmation.
func (m *StadiumMutation) RemovedStadiumConfirmationIDs() (ids []int) {
	for id := range m.removed_StadiumConfirmation {
		ids = append(ids, id)
	}
	return
}

// StadiumConfirmationIDs returns the StadiumConfirmation ids in the mutation.
func (m *StadiumMutation) StadiumConfirmationIDs() (ids []int) {
	for id := range m._StadiumConfirmation {
		ids = append(ids, id)
	}
	return
}

// ResetStadiumConfirmation reset all changes of the "StadiumConfirmation" edge.
func (m *StadiumMutation) ResetStadiumConfirmation() {
	m._StadiumConfirmation = nil
	m.removed_StadiumConfirmation = nil
}

// Op returns the operation name.
func (m *StadiumMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Stadium).
func (m *StadiumMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StadiumMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.namestadium != nil {
		fields = append(fields, stadium.FieldNamestadium)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StadiumMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stadium.FieldNamestadium:
		return m.Namestadium()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StadiumMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stadium.FieldNamestadium:
		return m.OldNamestadium(ctx)
	}
	return nil, fmt.Errorf("unknown Stadium field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StadiumMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stadium.FieldNamestadium:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamestadium(v)
		return nil
	}
	return fmt.Errorf("unknown Stadium field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StadiumMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StadiumMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StadiumMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Stadium numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StadiumMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StadiumMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StadiumMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Stadium nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StadiumMutation) ResetField(name string) error {
	switch name {
	case stadium.FieldNamestadium:
		m.ResetNamestadium()
		return nil
	}
	return fmt.Errorf("unknown Stadium field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StadiumMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._StadiumConfirmation != nil {
		edges = append(edges, stadium.EdgeStadiumConfirmation)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StadiumMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stadium.EdgeStadiumConfirmation:
		ids := make([]ent.Value, 0, len(m._StadiumConfirmation))
		for id := range m._StadiumConfirmation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StadiumMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_StadiumConfirmation != nil {
		edges = append(edges, stadium.EdgeStadiumConfirmation)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StadiumMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case stadium.EdgeStadiumConfirmation:
		ids := make([]ent.Value, 0, len(m.removed_StadiumConfirmation))
		for id := range m.removed_StadiumConfirmation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StadiumMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StadiumMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StadiumMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Stadium unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StadiumMutation) ResetEdge(name string) error {
	switch name {
	case stadium.EdgeStadiumConfirmation:
		m.ResetStadiumConfirmation()
		return nil
	}
	return fmt.Errorf("unknown Stadium edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	email                    *string
	password                 *string
	name                     *string
	birthday                 *time.Time
	telephone                *string
	clearedFields            map[string]struct{}
	_UserConfirmation        map[int]struct{}
	removed_UserConfirmation map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the password field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetName sets the name field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetBirthday sets the birthday field.
func (m *UserMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the birthday value in the mutation.
func (m *UserMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old birthday value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldBirthday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBirthday is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ResetBirthday reset all changes of the "birthday" field.
func (m *UserMutation) ResetBirthday() {
	m.birthday = nil
}

// SetTelephone sets the telephone field.
func (m *UserMutation) SetTelephone(s string) {
	m.telephone = &s
}

// Telephone returns the telephone value in the mutation.
func (m *UserMutation) Telephone() (r string, exists bool) {
	v := m.telephone
	if v == nil {
		return
	}
	return *v, true
}

// OldTelephone returns the old telephone value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldTelephone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTelephone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTelephone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelephone: %w", err)
	}
	return oldValue.Telephone, nil
}

// ResetTelephone reset all changes of the "telephone" field.
func (m *UserMutation) ResetTelephone() {
	m.telephone = nil
}

// AddUserConfirmationIDs adds the UserConfirmation edge to Confirmation by ids.
func (m *UserMutation) AddUserConfirmationIDs(ids ...int) {
	if m._UserConfirmation == nil {
		m._UserConfirmation = make(map[int]struct{})
	}
	for i := range ids {
		m._UserConfirmation[ids[i]] = struct{}{}
	}
}

// RemoveUserConfirmationIDs removes the UserConfirmation edge to Confirmation by ids.
func (m *UserMutation) RemoveUserConfirmationIDs(ids ...int) {
	if m.removed_UserConfirmation == nil {
		m.removed_UserConfirmation = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_UserConfirmation[ids[i]] = struct{}{}
	}
}

// RemovedUserConfirmation returns the removed ids of UserConfirmation.
func (m *UserMutation) RemovedUserConfirmationIDs() (ids []int) {
	for id := range m.removed_UserConfirmation {
		ids = append(ids, id)
	}
	return
}

// UserConfirmationIDs returns the UserConfirmation ids in the mutation.
func (m *UserMutation) UserConfirmationIDs() (ids []int) {
	for id := range m._UserConfirmation {
		ids = append(ids, id)
	}
	return
}

// ResetUserConfirmation reset all changes of the "UserConfirmation" edge.
func (m *UserMutation) ResetUserConfirmation() {
	m._UserConfirmation = nil
	m.removed_UserConfirmation = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.birthday != nil {
		fields = append(fields, user.FieldBirthday)
	}
	if m.telephone != nil {
		fields = append(fields, user.FieldTelephone)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldName:
		return m.Name()
	case user.FieldBirthday:
		return m.Birthday()
	case user.FieldTelephone:
		return m.Telephone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldBirthday:
		return m.OldBirthday(ctx)
	case user.FieldTelephone:
		return m.OldTelephone(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case user.FieldTelephone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelephone(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldBirthday:
		m.ResetBirthday()
		return nil
	case user.FieldTelephone:
		m.ResetTelephone()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._UserConfirmation != nil {
		edges = append(edges, user.EdgeUserConfirmation)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserConfirmation:
		ids := make([]ent.Value, 0, len(m._UserConfirmation))
		for id := range m._UserConfirmation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_UserConfirmation != nil {
		edges = append(edges, user.EdgeUserConfirmation)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserConfirmation:
		ids := make([]ent.Value, 0, len(m.removed_UserConfirmation))
		for id := range m.removed_UserConfirmation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserConfirmation:
		m.ResetUserConfirmation()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
